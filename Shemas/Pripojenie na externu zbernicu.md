![[pripojenie na externu zbernicu.png]]

Это **управляющая часть (Řadiaca časť)**, которая **подключает процессор к внешней шине** и организует цикл _fetch_ (выборка) + подачу адресов на MAR/чтение данных в MBR/загрузка IR.

### Внутренние шины:

- **IAR** (Internal Address Register bus) — _внутренняя адресная шина_ (n-битная).  
По ней передаются адреса **внутри** процессора.
- **IDB** (Internal Data Bus) — _внутренняя шина данных_ (n-битная).  
По ней передаются данные **внутри** (именно значения).

### Внешние шины:

- **EAB** (External Address Bus) — внешняя адресная шина n-бит (подписано ADDR).
- **EDB** (External Data Bus) — внешняя шина данных n-бит (подписано DATA).

> Иными словами, **MAR** "мостит" канал **IAR** <=> **EAB**, а также **MBR** "мостит" канал между **IDB** <=> **EDB**, что позволяет без коллизий соединить две части процессора воедино

### Буферы и зачем нужны тут:

1. **MBR (Memory Buffer Register):**
   - Вход: берет данные с **IDB**
   - Выход: удерживает и выдает на **EDB**
   - "Мостик" между ,,внутри,, и ,,снаружи,, - регистр

2. **MAR (Memory Adress Register):**
   - Вход: берет данные с **IAR**
   - Выход: удерживает и выдает на **EAB**
   - "Мостик" между ,,внутри,, и ,,снаружи,, для адрессов - регистр

> Важно заметить, что снова MBR двонаправленный в обе стороны , в отличии от MAR, который может только отдавать, и не может ничего принимать

### Внешние команды (справа красным):

Это линии управления внешними устройствами/памятью (активный ноль “#”):

- **MEMRD#** — чтение памяти
- **MEMWR#** — запись памяти
- **IORD#** — чтение порта ввода
- **IOWR#** — запись порта вывода

> Их формирует управляющая часть (не обязательно показано логикой тут, но стрелки “отсюда наружу”)

### Блок IR (Instruction Register):

IR хранит текущую инструкцию и обычно разделяется на:

- **OC** (opcode) — код операции
- **ADDR** — поле адреса/операнда (или часть инструкции)

**Откуда приходит значение?** 
 IR загружается **из IDB** (т.е. из внутренней шины данных), а значит типичный путь такой:
 
```
Память → EDB → MBR → IDB → IR
```

### Блоки слева: PC, INC и два MUX:
1. **PC (Program Counter)**:  
   - Хранит адрес следующей инструкции
   - Имеет флаг **reset** (обнуление)
   - **WR4** — запись нового значения в PC

2. I**NC (инкримент)**:
  - Инкриментирует **РС** на 1 (или другую константу)

3. **MUX2 (мультиплексор скачка):**
   - Выбирает какой адрес выдать на **IAB**
   - ***i0:*** Значение РС+1
   - ***i1:*** Значение IR addr.

41. **MUX1 (мультиплексор выбора):**
   - Выбирает что записывать в **РС**, новый адресс от прыжка или след от **INC**
   - ***i0:*** Значение РС
   - ***i1:*** Значение IR addr.

### Как это рисовать?
1.  Рисуем **IAВ** и **IDB** в оба направления, ставим блоки **MAR**, **MBR** и соеденяем их соответственно, выходы из **MAR**, **MBR** соединяем с **EAB** (только на выход!), **EDB** , Ставим на них управляющие сигналы **WRXX, RDAX** 
2.  Рисуем IR , рисуем части ОС | ADDR, в ADRR подключаем сигнал из **IAB**, сигнал из **OC** опускаем ниже в декодер (на схеме его нету) , добавляем сигнал чтения **WRX** для **IR**
3.  Рисуем слева в таком порядке **MUX**, **PC**, **MUX** , мультиплексоры имеют сигналы **MUXX**, **РС** - **WRX** и **RESET**, слева от **РС** рисуем **INC**
4.  Проводим **ADRR** в **MUX1**, **MUX2** , выход от верхнего **MUX** проводим к **IAB**
5.  Из **РС** провод идет вверх в верхний **MUX**, второй провод идет в **INC** , и далее в нижний **MUX**