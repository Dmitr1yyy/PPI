#sčítačka #scitacka #adder #сумматор

![[n-bitová sčítačka.png]]

Это **полный сумматор (Full Adder)** — схема, которая складывает **три бита**:

- **Ai** — первый входной бит
- **Bi** — второй входной бит
- **Ci** — входной перенос (carry-in)

На выходе она даёт:

- **Si** — сумма
- **Ci+1** — перенос в следующий разряд

По факту, происходит реализация такой операции: **Ai+Bi+Ci**, таблица операций (таблица истиности):

$$
\begin{array}{|c|c|c|c|c|}
\hline
A_i & B_i & C_i & S_i & C_{i+1} \\
\hline
0 & 0 & 0 & 0 & 0 \\
0 & 0 & 1 & 1 & 0 \\
0 & 1 & 0 & 1 & 0 \\
0 & 1 & 1 & 0 & 1 \\
1 & 0 & 0 & 1 & 0 \\
1 & 0 & 1 & 0 & 1 \\
1 & 1 & 0 & 0 & 1 \\
1 & 1 & 1 & 1 & 1 \\
\hline
\end{array}
$$

 Математическое вычисление суммы для текущей позиции бита высчитывается через тройной _XOR_: $$(A \oplus B) \oplus C$$ $$
\begin{array}{|c|c|c|c|}
\hline
A & B & C & A \oplus B \oplus C \\
\hline
0 & 0 & 0 & 0 \\
0 & 0 & 1 & 1 \\
0 & 1 & 0 & 1 \\
0 & 1 & 1 & 0 \\
1 & 0 & 0 & 1 \\
1 & 0 & 1 & 0 \\
1 & 1 & 0 & 0 \\
1 & 1 & 1 & 1 \\
\hline
\end{array}
$$

### Что делают компоненты?

1. Три логических _AND_-а делают побитовое сравнение для проверки всех возможных случаев, когда случится переход (Когда **Ci** горит как "1" и в результате сложения **Ai** и **Bi** также будет единицой)
2.  Логический _XOR_ между тремя переменными срабатывает определяя логический результат математической операции. **! Несколько вступной XOR возвращает единицу, если колличество единиц на входе *НЕПАРНОЕ* !** 

### Как рисовать?

1. Сверху ставится 3 входа: **Ai, Bi, Ci**, Провода от них сразу же опускаются вниз к логическому _XOR_ для этих трех операций, выходом из логического _XOR_-а будет сумма **Si**
2. Рисуем 3 логических двойных _AND_-а, по таким парам: **Ai & Bi**, **Bi & Ci**, **Bi & Ci** 
3. Результат предыдущих трёх _AND_-ов продливаем и проводим в логический _OR_ 
4. Результат логического _OR_-a выходит в **Ci+1** 

