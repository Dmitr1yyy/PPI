#OČ #RČ 

![[návrh RČ procesora – prepojenie OČ s RČ.png]]

Эта схема показывает как **управляющая часть (ŘČ)** управляет **операционной частью (OČ)**, так как процессор логически разделен на 2 части. Краткая идея схемы это замкнутый цикл:

```
ŘČ посылает управляющие сигналы → OČ выполняет действия → возвращает состояние обратно в ŘČ
```

### Что происходит в операционной части? (OČ)

Лишь то, что **работает с данными**:

- Регистры
- АЛУ 
- Внутренние шины
- Флаги

> OČ не может решать что сделать, а что нет, она лишь исполнитель, ей говорят что - и она делает, и возвращает результат куда скажут.

### Что происходит в управляющей части? (RČ)

Только управляющие **действия (приказы)**:

-  Что нужно сделать?
-  В каком порядке?
-  Какие сигналы подать?
-  Куда?
-  Когда?

> RČ не может делать вычислительные, или логические операции, но может управлять OČ, которая выполнит это и скажет результат.

### Компоненты RČ:

1. **PC** — Program Counter, хранит адрес следующей инструкуции
2. **IR** — Instruction Register, хранит текущую инструкцию
3. **k** — interne povely, многобитовый кабель для передачи управляющих сигналов
4. **stav** — status, хранит флаги логических операций

##### Флаги, которые нужны:

1. ***N (Negative)*** - результат операции отрицательное число
2. ***Z (Zero)*** - результат операции это ноль
3. ***V (Overflow)*** - переполнение, переливание в знаковый бит, ошибка
4. ***C (Carry)*** - перенос в следующий бит

### Два регистра памяти, какой для чего?

**MAR** — Memory Address Register:

- Хранит адрес памяти (только адрес!)
- Подключён к **EAB** (external address bus)
  
> Только MAR может выставлять адрес наружу.

**MBR** — Memory Buffer Register:

- Хранит данные из памяти
- Подключён к **EDB** (external data bus)
  
> Буфер между памятью и процессором.

### Внешние сигналы управления памятью:

***Важно:*** Сигналы управления всегда инверсионные, **#** - NOT. Так безопаснее и меньше риск колизии на стороне железа, это связано с физикой.

$$
\begin{array}{|c|l|}
\hline
\text{Сигнал} & \text{Назначение} \\
\hline
\text{MEMRD\#} & \text{Чтение из памяти (Memory Read)} \\
\hline
\text{MEMWR\#} & \text{Запись в память (Memory Write)} \\
\hline
\text{IORD\#} & \text{Чтение из порта ввода-вывода (I/O Read)} \\
\hline
\text{IOWR\#} & \text{Запись в порт ввода-вывода (I/O Write)} \\
\hline
\end{array}
$$

### Составные OČ:

1.  Внутренние регистры (AX, BX, CX, DX), в свою очередь, каждый регистр имеет два сигнала: сигнал чтения (**RDXX**), и сигнал записи (**WRXX**).
2.  IDB (Internal Data Bus) - шина данных, которая передает буквально все (данные, адресса, результаты ALU), в каждый момент времени **1** источник и **много** приемников.
3.  TMP1, PM2 - временные регистры, хранят операнды для АЛУ, защищают от колизии
4.  АЛУ - выполняет все логические операции и вычисления, результат подает на шину

### Фазы работы:

1.  **Fetch (Выборка)** - берем инструкцию: 
```
PC → MAR
MEMRD#
данные → MBR
MBR → IR
PC++   
```

2. **Decode (Декодирование)** - понимаем что за инструкция:
```
ŘČ анализирует IR
формирует последовательность микроопераций
```

3. **Execute (Исполнение)** - поэтапное выполнение микроопераций:

> Пример выполнения **ADD AX, BX**:

```
RDBX → IDB
TMP1 ← IDB  
RDAX → IDB  
TMP2 ← IDB
ALU = ADD
результат → IDB
WRAX
```

### Как нарисовать?

1. Рисуем большой прямоугольник , внутри которого располагаем 2 области: сверху **RČ**, снизу **OČ**, подписываем их.
2.  В **RČ** рисуем элементы: **PC, IR** справа, **MAR, MBR**, ставим флаги управления в любом порядке ниже: **#MEMRD**, **#MEMWR**, **#IORD**, **#IOWR**, и проводим от них провода вправо
3.  Соединяем **MAR, MBR** , **MAR** (!ТОЛЬКО) отдает, а **MBR** еще и принимает, подписываем где идут данные, а где адреса
4.  Переходим к **ОČ** , рисуем шину и подписываем ее **IDB**, рисуем 4 регистра в ряд (AX, BX, CX, DX). к каждому из них ставим управляющий сигнал (WRXX & RDXX)
5.  Подключаем все регистры к шине, и добавляем ниже под шиной два временныхх регистра для операндов **TMP1, TMP2** , которые имеют управляющий сигнал **WTX** 
6.  Рисуем АЛУ ниже и подключаем к ней два временных регистра, справа добавляем сигналы **P1, P2, Pn.., RDALU** , слева выходят флаги АЛУ
7.  Результат АЛУ выходит на общую шину
8.  Из **RČ** справа идет соединяющий **k** n-битовый провод в **ОČ**, он однонаправленный, состояния из **ОČ** выходят справа и идут обратно в **RČ**